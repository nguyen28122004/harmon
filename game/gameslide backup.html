<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <title>Game k√©o th·∫£</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: 'Segoe UI', sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #f5f0f0;
        }
        
        #contextMenu {
            position: absolute;
            background: #fff0f5;
            border: 1px solid #f4b6c2;
            border-radius: 10px;
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.1);
            padding: 8px;
            display: none;
            z-index: 9999;
            font-size: 14px;
            color: #d16b86;
            min-width: 180px;
        }
        
        #contextMenu button {
            display: block;
            width: 100%;
            padding: 6px 12px;
            background: none;
            border: none;
            text-align: left;
            font-family: inherit;
            color: inherit;
            cursor: pointer;
            border-radius: 8px;
            transition: background 0.2s ease;
        }
        
        #contextMenu button:hover {
            background: #ffeef4;
        }
        
        .sidebar {
            min-width: 100px !important;
            width: 100px;
            background: #fff0f5;
            overflow-y: auto;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
            box-shadow: 4px 0 12px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease-in-out;
            border-right: 1px solid #ffe4ec;
            overflow-x: hidden;
        }
        
        .sidebar canvas {
            width: 64px !important;
            height: 64px !important;
            cursor: grab;
            border-radius: 12px;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
            background-color: white;
            padding: 2px;
        }
        
        .sidebar canvas:hover {
            transform: scale(1.1);
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.15);
        }
        
        .sidebar::-webkit-scrollbar {
            width: 6px;
        }
        
        .sidebar::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .sidebar::-webkit-scrollbar-thumb {
            background: #f4b6c2;
            border-radius: 8px;
            transition: background 0.3s ease;
        }
        
        .sidebar::-webkit-scrollbar-thumb:hover {
            background: #f194b4;
        }
        
        .rightbar {
            width: 160px;
            /* tƒÉng t·ª´ 100px */
            background: #fff0f5;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px 10px;
            box-shadow: -4px 0 12px rgba(0, 0, 0, 0.1);
            border-left: 1px solid #ffe4ec;
            gap: 20px;
        }
        
        .snap-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
            font-size: 14px;
            font-weight: 500;
            color: #d16b86;
            user-select: none;
            gap: 10px;
            /* <-- Th√™m d√≤ng n√†y */
        }
        
        .snap-toggle .label-text {
            flex-shrink: 0;
        }
        /* Reuse switch styles */
        
        .switch {
            position: relative;
            display: inline-block;
            width: 46px;
            height: 24px;
        }
        
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .slider {
            position: absolute;
            cursor: pointer;
            background-color: #f4b6c2;
            border-radius: 24px;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            transition: 0.3s;
        }
        
        .slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 3px;
            bottom: 3px;
            background-color: white;
            border-radius: 50%;
            transition: 0.3s;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
        }
        
        input:checked+.slider {
            background-color: #f194b4;
        }
        
        input:checked+.slider:before {
            transform: translateX(22px);
        }
        
        #resetBtn {
            padding: 10px 14px;
            background: #f4b6c2;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.1);
            transition: all 0.25s ease-in-out;
        }
        
        #resetBtn:hover {
            background: #f194b4;
            transform: translateY(-2px);
            box-shadow: 0 6px 14px rgba(0, 0, 0, 0.2);
        }
        
        .scale-control {
            width: 100%;
            padding: 10px;
            background-color: #ffeef4;
            border-radius: 12px;
            box-shadow: inset 0 0 4px rgba(0, 0, 0, 0.05);
            display: flex;
            flex-direction: column;
            align-items: center;
            font-size: 14px;
            font-weight: 500;
            color: #d16b86;
            gap: 6px;
        }
        
        #scaleSlider {
            width: 100%;
            appearance: none;
            height: 6px;
            background: #f4b6c2;
            border-radius: 4px;
            outline: none;
            transition: background 0.3s ease;
            cursor: pointer;
        }
        
        #scaleSlider::-webkit-slider-thumb {
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            border: 2px solid #f194b4;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }
        
        #scaleSlider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: white;
            border: 2px solid #f194b4;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        #gamearea {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: scroll;
        }
        
        #gamearea::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        #gamearea::-webkit-scrollbar-track {
            background: #fff5f8;
            border-radius: 10px;
        }
        
        #gamearea::-webkit-scrollbar-thumb {
            background: #f4b6c2;
            border-radius: 10px;
            border: 2px solid #fff5f8;
            transition: background 0.3s ease;
        }
        
        #gamearea::-webkit-scrollbar-thumb:hover {
            background: #f194b4;
        }
        
        #gameCanvasWrapper {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 100%;
            height: 100%;
            overflow: auto;
        }
        
        #gameCanvasWrapper::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        #gameCanvasWrapper::-webkit-scrollbar-track {
            background: #fff5f8;
            border-radius: 10px;
        }
        
        #gameCanvasWrapper::-webkit-scrollbar-thumb {
            background: #f4b6c2;
            border-radius: 10px;
            border: 2px solid #fff5f8;
            transition: background 0.3s ease;
        }
        
        #gameCanvasWrapper::-webkit-scrollbar-thumb:hover {
            background: #f194b4;
        }
        
        #gameCanvas {
            width: 1000px;
            height: 1000px;
            min-width: 1000px;
            min-height: 1000px;
            position: relative;
            transform-origin: top left;
            /* ho·∫∑c center n·∫øu b·∫°n mu·ªën zoom t·ª´ gi·ªØa */
            transition: transform 0.3s ease;
        }
        
        #backImage {
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            position: absolute;
            height: 100%;
            object-fit: contain;
            /* ‚úÖ Ch·ªâ ƒë·ªï b√≥ng cho h√¨nh ·∫£nh */
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.25);
            border-radius: 16px;
            /* Optional n·∫øu b·∫°n mu·ªën bo g√≥c */
            z-index: 0;
            pointer-events: none;
            /* ƒê·ªÉ kh√¥ng c·∫£n c√°c item k√©o th·∫£ */
        }
        
        .game-item {
            position: absolute;
            cursor: grab;
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        
        .game-item:active {
            cursor: grabbing;
            transform: scale(1.05);
            box-shadow: 0 6px 15px rgba(0, 0, 0, 0.25);
            z-index: 1000;
        }
        
        #logBtn {
            margin-top: 10px;
            padding: 6px 12px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s ease;
        }
        
        #logBtn:hover {
            background: #555;
        }
    </style>

</head>

<body>
    <div class="sidebar" id="sidebar"></div>
    <div id="gamearea">
        <div id="gameCanvasWrapper">
            <div id="gameCanvas">
                <img id="backImage" src="../gameAssets/back.png" alt="Background" />
            </div>
        </div>

        <!-- <button id="logBtn" onclick="logAllItemPositions()">Log to√†n b·ªô v·ªã tr√≠</button> -->
    </div>
    <div class="rightbar">
        <button id="resetBtn">Reset Items</button>
        <div class="snap-toggle">
            <label class="label-text">Snap Position</label>
            <label class="switch">
              <input type="checkbox" id="snapToggle" checked>
              <span class="slider"></span>
            </label>
        </div>
        <div class="scale-control">
            <label>Scale: <span id="scaleValue">1.0</span>x</label>
            <input type="range" id="scaleSlider" min="0.1" max="2" step="0.1" value="1">
        </div>
        <div id="contextMenu"></div>

    </div>


    <script>
        const items = {
            brickBackground: {
                src: '../gameAssets/brickBackground.png',
                frames: 1,
                scale: 0.883,
                layer: 0,
                targetPosition: {
                    x: 170,
                    y: 115
                }
            },
            bottomMessages: {
                src: '../gameAssets/bottomMessages.png',
                frames: 1,
                scale: 0.883,
                layer: 1,
                targetPosition: {
                    x: 170,
                    y: 115
                }
            },
            gasStove: {
                src: '../gameAssets/gasStove.png',
                frames: 1,
                scale: 1,
                layer: 2,
                targetPosition: {
                    x: 170,
                    y: 535
                }
            },
            Oven: {
                src: '../gameAssets/Oven.png',
                frames: 1,
                scale: 1,
                layer: 3,
                targetPosition: {
                    x: 265,
                    y: 455
                }
            },
            creamRug: {
                src: '../gameAssets/creamRug.png',
                frames: 1,
                scale: 1,
                layer: 4,
                targetPosition: {
                    x: 375,
                    y: 445
                }
            },
            table: {
                src: '../gameAssets/table.png',
                frames: 1,
                scale: 1.02,
                layer: 5,
                targetPosition: {
                    x: 710,
                    y: 545
                }
            },
            sofa: {
                src: '../gameAssets/sofa.png',
                frames: 1,
                scale: 1,
                layer: 6,
                targetPosition: {
                    x: 540,
                    y: 460
                }
            },
            eggmon: {
                src: '../gameAssets/eggmon.png',
                frames: 4,
                scale: 0.4,
                layer: 7,
                targetPosition: {
                    x: 400,
                    y: 545
                }
            },
            hamster: {
                src: '../gameAssets/hamster.png',
                frames: 4,
                scale: 0.1,
                layer: 7,
                targetPosition: {
                    x: 585,
                    y: 550
                }
            },
            letterBox: {
                src: '../gameAssets/letterBox.png',
                frames: 1,
                scale: 1,
                layer: 8,
                targetPosition: {
                    x: 740,
                    y: 665
                }
            },
            plant1: {
                src: '../gameAssets/plant1.png',
                frames: 1,
                scale: 1,
                layer: 9,
                targetPosition: {
                    x: 275,
                    y: 630
                }
            },
            plant2: {
                src: '../gameAssets/plant2.png',
                frames: 1,
                scale: 1,
                layer: 10,
                targetPosition: {
                    x: 610,
                    y: 660
                }
            },
            plant3: {
                src: '../gameAssets/plant3.png',
                frames: 1,
                scale: 1,
                layer: 11,
                targetPosition: {
                    x: 660,
                    y: 825
                }
            },
            light: {
                src: '../gameAssets/light.png',
                frames: 1,
                scale: 1,
                layer: 12,
                targetPosition: {
                    x: 415,
                    y: 175
                }
            },
            wallShelves: {
                src: '../gameAssets/wallShelves.png',
                frames: 1,
                scale: 1,
                layer: 13,
                targetPosition: {
                    x: 230,
                    y: 225
                }
            },
            window: {
                src: '../gameAssets/window.png',
                frames: 1,
                scale: 1,
                layer: 14,
                targetPosition: {
                    x: 590,
                    y: 220
                }
            }
        };

        const sidebar = document.getElementById('sidebar');
        const gameCanvas = document.getElementById('gameCanvas');
        const activeItems = new Set();

        function snapToGrid(x, y, gridSize = 5) {
            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        function saveItemStates() {
            const itemStates = [];
            const items = gameCanvas.querySelectorAll('.game-item');

            items.forEach((item) => {
                const key = item.dataset.key;
                const position = JSON.parse(item.dataset.position || '{}');
                itemStates.push({
                    key,
                    position
                });
            });

            localStorage.setItem('gameItemStates', JSON.stringify(itemStates));
        }

        let snapEnabled = true;

        document.getElementById('snapToggle').addEventListener('change', (e) => {
            snapEnabled = e.target.checked;
        });

        function createCanvasItem(key, meta, isClone = false, initialOffset = {
            x: 0,
            y: 0
        }, initialPosition = {
            x: 0,
            y: 0
        }) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.src = meta.src;

            let frameWidth, frameHeight;
            let currentFrame = 0;

            canvas.classList.add(isClone ? 'game-item' : 'sidebar-item');

            img.onload = () => {
                frameWidth = img.width / meta.frames;
                frameHeight = img.height;
                canvas.width = frameWidth * meta.scale;
                canvas.height = frameHeight * meta.scale;

                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Thi·∫øt l·∫≠p ƒë·ªï b√≥ng m·ªÅm, ƒë·∫πp
                ctx.shadowColor = 'rgba(0,0,0,0.2)';
                ctx.shadowBlur = 12;
                ctx.shadowOffsetX = 0;
                ctx.shadowOffsetY = 6;

                // Bo g√≥c: d√πng roundRect v√† clip ƒë·ªÉ gi·ªõi h·∫°n v√πng v·∫Ω
                ctx.save();
                ctx.beginPath();
                ctx.roundRect(0, 0, canvas.width, canvas.height, 12); // 12px bo g√≥c
                ctx.clip();

                // V·∫Ω ·∫£nh c√≥ hi·ªáu ·ª©ng shadow
                ctx.drawImage(img, currentFrame * frameWidth, 0, frameWidth, frameHeight, 0, 0, canvas.width, canvas.height);
                ctx.restore();


                if (meta.frames > 1 && isClone) {
                    let lastTime = performance.now();
                    const frameDuration = 200;

                    function animate(time) {
                        const elapsed = time - lastTime;
                        if (elapsed > frameDuration) {
                            currentFrame = (currentFrame + 1) % meta.frames;
                            lastTime = time;
                        }
                        ctx.clearRect(0, 0, canvas.width, canvas.height);

                        // Thi·∫øt l·∫≠p ƒë·ªï b√≥ng m·ªÅm, ƒë·∫πp
                        ctx.shadowColor = 'rgba(0,0,0,0.2)';
                        ctx.shadowBlur = 12;
                        ctx.shadowOffsetX = 0;
                        ctx.shadowOffsetY = 6;

                        // Bo g√≥c: d√πng roundRect v√† clip ƒë·ªÉ gi·ªõi h·∫°n v√πng v·∫Ω
                        ctx.save();
                        ctx.beginPath();
                        ctx.roundRect(0, 0, canvas.width, canvas.height, 12); // 12px bo g√≥c
                        ctx.clip();

                        // V·∫Ω ·∫£nh c√≥ hi·ªáu ·ª©ng shadow
                        ctx.drawImage(img, currentFrame * frameWidth, 0, frameWidth, frameHeight, 0, 0, canvas.width, canvas.height);
                        ctx.restore();

                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);
                }
            };

            let offsetX, offsetY;
            let dragging = false;
            let lastTouchX = 0,
                lastTouchY = 0;

            const startDrag = (clientX, clientY) => {
                const rect = canvas.getBoundingClientRect();
                offsetX = clientX - rect.left;
                offsetY = clientY - rect.top;
            };

            const updatePosition = (clientX, clientY) => {
                const gameRect = gameCanvas.getBoundingClientRect();
                let newX = clientX - gameRect.left - offsetX;
                let newY = clientY - gameRect.top - offsetY;
                canvas.style.left = newX + 'px';
                canvas.style.top = newY + 'px';
            };

            const endDrag = (clientX, clientY) => {
                const sidebarRect = sidebar.getBoundingClientRect();
                const gameRect = gameCanvas.getBoundingClientRect();
                const dropX = clientX - gameRect.left - offsetX;
                const dropY = clientY - gameRect.top - offsetY;

                if (clientX >= sidebarRect.left && clientX <= sidebarRect.right &&
                    clientY >= sidebarRect.top && clientY <= sidebarRect.bottom) {
                    if (canvas.parentNode === gameCanvas) gameCanvas.removeChild(canvas);
                    if (!document.getElementById('sidebar-' + key)) {
                        const newItem = createCanvasItem(key, meta);
                        newItem.id = 'sidebar-' + key;
                        sidebar.appendChild(newItem);
                    }
                    activeItems.delete(key);
                } else {
                    let finalX = dropX;
                    let finalY = dropY;

                    if (snapEnabled && meta.targetPosition) {
                        const dx = dropX - meta.targetPosition.x;
                        const dy = dropY - meta.targetPosition.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const snapThreshold = 50;
                        if (dist <= snapThreshold) {
                            finalX = meta.targetPosition.x;
                            finalY = meta.targetPosition.y;
                        } else {
                            const snapped = snapToGrid(dropX, dropY);
                            finalX = snapped.x;
                            finalY = snapped.y;
                        }
                    } else {
                        const snapped = snapToGrid(dropX, dropY);
                        finalX = snapped.x;
                        finalY = snapped.y;
                    }


                    canvas.style.left = finalX + 'px';
                    canvas.style.top = finalY + 'px';
                    canvas.style.zIndex = meta.layer || 1;
                    canvas.dataset.position = JSON.stringify({
                        x: finalX,
                        y: finalY
                    });
                    canvas.dataset.key = key;
                    saveItemStates();
                    console.log(`Item "${key}" position: (${finalX}, ${finalY})`);
                }
            };

            const onMouseDown = (e) => {
                if (canvas.dataset.locked === 'true') return;

                dragging = true;
                startDrag(e.clientX, e.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };
            const onMouseMove = (e) => {
                if (!dragging) return;
                updatePosition(e.clientX, e.clientY);
            };
            const onMouseUp = (e) => {
                if (!dragging) return;
                dragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                endDrag(e.clientX, e.clientY);
            };

            const onTouchStart = (e) => {
                if (canvas.dataset.locked === 'true') return;

                if (e.touches.length !== 1) return;
                dragging = true;
                const touch = e.touches[0];
                startDrag(touch.clientX, touch.clientY);
                document.addEventListener('touchmove', onTouchMove, {
                    passive: false
                });
                document.addEventListener('touchend', onTouchEnd);
            };
            const onTouchMove = (e) => {
                if (!dragging || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                updatePosition(touch.clientX, touch.clientY);
            };
            const onTouchEnd = () => {
                if (!dragging) return;
                dragging = false;
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                endDrag(lastTouchX, lastTouchY);
            };

            if (isClone) {
                canvas.style.left = initialPosition.x + 'px';
                canvas.style.top = initialPosition.y + 'px';
                canvas.style.zIndex = meta.layer || 1;

                // üñ± Mouse down
                canvas.addEventListener('mousedown', (e) => {
                    if (e.button === 2) return; // ‚úÖ Chu·ªôt ph·∫£i cho ph√©p
                    if (canvas.dataset.ignoreClick === 'true') return; // üõë Kh√¥ng drag, scale
                    onMouseDown(e);
                });

                // ‚òùÔ∏è Touch start
                canvas.addEventListener('touchstart', (e) => {
                    if (canvas.dataset.ignoreClick === 'true') return; // üõë Kh√¥ng drag c·∫£m ·ª©ng
                    onTouchStart(e);
                }, {
                    passive: false
                });

                // üîÅ Ho√†n tr·∫£ (dblclick)
                canvas.addEventListener('dblclick', () => {
                    if (canvas.dataset.ignoreClick === 'true') return; // üõë Kh√¥ng ho√†n tr·∫£
                    if (canvas.parentNode === gameCanvas) gameCanvas.removeChild(canvas);
                    if (!document.getElementById('sidebar-' + key)) {
                        const newItem = createCanvasItem(key, meta);
                        newItem.id = 'sidebar-' + key;
                        sidebar.appendChild(newItem);
                    }
                    activeItems.delete(key);
                });
            } else {
                canvas.id = 'sidebar-' + key;
                canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (activeItems.has(key)) return;
                    const sidebarRect = canvas.getBoundingClientRect();
                    const gameRect = gameCanvas.getBoundingClientRect();
                    const offsetX = e.clientX - sidebarRect.left;
                    const offsetY = e.clientY - sidebarRect.top;
                    const posX = e.clientX - gameRect.left - offsetX;
                    const posY = e.clientY - gameRect.top - offsetY;
                    const clone = createCanvasItem(key, meta, true, {
                        x: offsetX,
                        y: offsetY
                    }, {
                        x: posX,
                        y: posY
                    });
                    gameCanvas.appendChild(clone);
                    activeItems.add(key);
                    canvas.remove();
                    const event = new MouseEvent('mousedown', {
                        clientX: e.clientX,
                        clientY: e.clientY
                    });
                    clone.dispatchEvent(event);
                });
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (activeItems.has(key)) return;
                    const touch = e.touches[0];
                    const sidebarRect = canvas.getBoundingClientRect();
                    const gameRect = gameCanvas.getBoundingClientRect();
                    const offsetX = touch.clientX - sidebarRect.left;
                    const offsetY = touch.clientY - sidebarRect.top;
                    const posX = touch.clientX - gameRect.left - offsetX;
                    const posY = touch.clientY - gameRect.top - offsetY;
                    const clone = createCanvasItem(key, meta, true, {
                        x: offsetX,
                        y: offsetY
                    }, {
                        x: posX,
                        y: posY
                    });
                    gameCanvas.appendChild(clone);
                    activeItems.add(key);
                    canvas.remove();
                    clone.dispatchEvent(new TouchEvent('touchstart', {
                        touches: [touch],
                        cancelable: true,
                        bubbles: true
                    }));
                }, {
                    passive: false
                });
            }
            attachContextMenu(canvas, key, meta);
            return canvas;
        }

        function logAllItemPositions() {
            const items = gameCanvas.querySelectorAll('.game-item');
            items.forEach((item, i) => {
                const key = item.dataset.key || `item-${i}`;
                const pos = JSON.parse(item.dataset.position || '{}');
                console.log(`${key}:`, pos);
            });
        }
        // Kh√¥i ph·ª•c tr·∫°ng th√°i n·∫øu c√≥
        const savedStates = JSON.parse(localStorage.getItem('gameItemStates') || '[]');
        const keysPlaced = new Set();

        savedStates.forEach(({
            key,
            position
        }) => {
            if (items[key]) {
                const meta = items[key];
                const clone = createCanvasItem(key, meta, true, {}, position);
                clone.dataset.position = JSON.stringify(position);
                clone.dataset.key = key;
                gameCanvas.appendChild(clone);
                activeItems.add(key);
                keysPlaced.add(key);
            }
        });

        for (const key in items) {
            if (!keysPlaced.has(key)) {
                const canvas = createCanvasItem(key, items[key]);
                canvas.id = 'sidebar-' + key;
                sidebar.appendChild(canvas);
            }
        }


        const scaleSlider = document.getElementById('scaleSlider');
        const scaleValue = document.getElementById('scaleValue');

        scaleSlider.addEventListener('input', () => {
            const scale = parseFloat(scaleSlider.value);
            const canvas = document.getElementById('gameCanvas');

            // T√≠nh to√°n ƒë·ªÉ gi·ªØ canvas ·ªü gi·ªØa
            const translateX = (1 - scale) * canvas.offsetWidth / 2;
            const translateY = (1 - scale) * canvas.offsetHeight / 2;

            canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            scaleValue.textContent = scale.toFixed(1);
        });



        document.getElementById('resetBtn').addEventListener('click', () => {
            // X√≥a to√†n b·ªô item hi·ªán t·∫°i tr√™n canvas
            const itemsOnCanvas = gameCanvas.querySelectorAll('.game-item');
            itemsOnCanvas.forEach((item) => item.remove());

            // X√≥a localStorage
            localStorage.removeItem('gameItemStates');

            // Reset sidebar
            sidebar.innerHTML = '';
            for (const key in items) {
                const canvas = createCanvasItem(key, items[key]);
                canvas.id = 'sidebar-' + key;
                sidebar.appendChild(canvas);
            }

            activeItems.clear();
        });

        // Ctrl + scroll ƒë·ªÉ thay ƒë·ªïi scale, kh√¥ng zoom tr√¨nh duy·ªát
        window.addEventListener('wheel', (e) => {
            if (e.ctrlKey) {
                e.preventDefault();

                let scale = parseFloat(scaleSlider.value);
                const delta = e.deltaY < 0 ? 0.1 : -0.1; // Scroll up => tƒÉng scale

                scale = Math.min(2, Math.max(0.1, scale + delta));
                scaleSlider.value = scale.toFixed(1);
                scaleValue.textContent = scale.toFixed(1);

                const canvas = document.getElementById('gameCanvas');
                const translateX = (1 - scale) * canvas.offsetWidth / 2;
                const translateY = (1 - scale) * canvas.offsetHeight / 2;
                canvas.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            }
        }, {
            passive: false
        });

        const contextMenu = document.getElementById('contextMenu');
        let contextTarget = null;

        // X·ª≠ l√Ω click chu·ªôt ph·∫£i tr√™n item
        function attachContextMenu(canvas, key, meta) {
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                contextTarget = canvas;

                const pos = JSON.parse(canvas.dataset.position || '{}');
                const locked = canvas.dataset.locked === 'true';
                const ignoreClick = canvas.dataset.ignoreClick === 'true';

                contextMenu.innerHTML = `
            <button disabled>üîç <b>${key}</b> ‚Äî (${pos.x ?? 0}, ${pos.y ?? 0}) ‚Äî Layer ${meta.layer ?? 1}</button>
            <button id="toggleLock">${locked ? 'üîì M·ªü kh√≥a v·ªã tr√≠' : 'üîí Kh√≥a v·ªã tr√≠'}</button>
            <button id="toggleClick">${ignoreClick ? 'üñ±Ô∏è Cho ph√©p click tr√°i' : 'üö´ B·ªè qua click tr√°i'}</button>
        `;

                contextMenu.style.left = `${e.pageX}px`;
                contextMenu.style.top = `${e.pageY}px`;
                contextMenu.style.display = 'block';
            });
        }

        // Click ngo√†i th√¨ ·∫©n menu
        window.addEventListener('click', () => {
            contextMenu.style.display = 'none';
        });

        // X·ª≠ l√Ω c√°c h√†nh ƒë·ªông trong menu
        contextMenu.addEventListener('click', (e) => {
            if (!contextTarget) return;
            const id = e.target.id;

            if (id === 'toggleLock') {
                const isLocked = contextTarget.dataset.locked === 'true';
                contextTarget.dataset.locked = (!isLocked).toString();
                // Kh√¥ng ƒë·ªïi pointerEvents ƒë·ªÉ v·∫´n cho ph√©p chu·ªôt ph·∫£i
            }

            if (id === 'toggleClick') {
                const ignoreClick = contextTarget.dataset.ignoreClick === 'true';
                contextTarget.dataset.ignoreClick = (!ignoreClick).toString();
                // Kh√¥ng ƒë·ªïi pointerEvents ƒë·ªÉ chu·ªôt ph·∫£i v·∫´n ho·∫°t ƒë·ªông
            }

            contextMenu.style.display = 'none';
        });
    </script>
</body>

</html>