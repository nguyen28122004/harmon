<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8" />
    <title>Game kéo thả</title>
    <style>
        * {
            box-sizing: border-box;
        }
        
        body {
            margin: 0;
            font-family: sans-serif;
            display: flex;
            height: 100vh;
            overflow: hidden;
            background: #c0c0c0;
        }
        
        .sidebar {
            min-width: 64px !important;
            width: 80px;
            background: #efefef;
            overflow-y: auto;
            padding: 10px 5px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }
        
        .sidebar canvas {
            width: 64px !important;
            height: 64px !important;
            cursor: grab;
        }
        
        #gamearea {
            flex: 1;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow: scroll;
        }
        
        #gamearea::-webkit-scrollbar {
            background-color: transparent;
            width: 5px !important;
            max-width: 5px;
            min-width: 5px;
        }
        
        #gamearea::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.07);
            border-radius: 50px;
        }
        
        #gameCanvas {
            background: url("../gameAssets/back.png") no-repeat center center;
            background-size: contain;
            width: 1000px;
            height: 1000px;
            min-width: 1000px;
            min-height: 1000px;
            position: relative;
        }
        
        .game-item {
            position: absolute;
            cursor: grab;
        }
        
        #logBtn {
            margin-top: 10px;
            padding: 6px 12px;
            background: #333;
            color: white;
            border: none;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #logBtn:hover {
            background: #555;
        }
    </style>
</head>

<body>
    <div class="sidebar" id="sidebar"></div>
    <div id="gamearea">
        <div id="gameCanvas"></div>
        <!-- <button id="logBtn" onclick="logAllItemPositions()">Log toàn bộ vị trí</button> -->
    </div>

    <script>
        const items = {
            brickBackground: {
                src: '../gameAssets/brickBackground.png',
                frames: 1,
                scale: 0.883,
                layer: 0,
                targetPosition: {
                    x: 170,
                    y: 115
                }
            },
            bottomMessages: {
                src: '../gameAssets/bottomMessages.png',
                frames: 1,
                scale: 0.883,
                layer: 1,
                targetPosition: {
                    x: 170,
                    y: 115
                }
            },
            gasStove: {
                src: '../gameAssets/gasStove.png',
                frames: 1,
                scale: 1,
                layer: 2,
                targetPosition: {
                    x: 170,
                    y: 535
                }
            },
            Oven: {
                src: '../gameAssets/Oven.png',
                frames: 1,
                scale: 1,
                layer: 3,
                targetPosition: {
                    x: 265,
                    y: 455
                }
            },
            creamRug: {
                src: '../gameAssets/creamRug.png',
                frames: 1,
                scale: 1,
                layer: 4,
                targetPosition: {
                    x: 375,
                    y: 445
                }
            },
            table: {
                src: '../gameAssets/table.png',
                frames: 1,
                scale: 1.02,
                layer: 5,
                targetPosition: {
                    x: 710,
                    y: 545
                }
            },
            sofa: {
                src: '../gameAssets/sofa.png',
                frames: 1,
                scale: 1,
                layer: 6,
                targetPosition: {
                    x: 540,
                    y: 460
                }
            },
            eggmon: {
                src: '../gameAssets/eggmon.png',
                frames: 4,
                scale: 0.4,
                layer: 7,
                targetPosition: {
                    x: 400,
                    y: 545
                }
            },
            hamster: {
                src: '../gameAssets/hamster.png',
                frames: 4,
                scale: 0.1,
                layer: 7,
                targetPosition: {
                    x: 585,
                    y: 550
                }
            },
            letterBox: {
                src: '../gameAssets/letterBox.png',
                frames: 1,
                scale: 1,
                layer: 8,
                targetPosition: {
                    x: 740,
                    y: 665
                }
            },
            plant1: {
                src: '../gameAssets/plant1.png',
                frames: 1,
                scale: 1,
                layer: 9,
                targetPosition: {
                    x: 275,
                    y: 630
                }
            },
            plant2: {
                src: '../gameAssets/plant2.png',
                frames: 1,
                scale: 1,
                layer: 10,
                targetPosition: {
                    x: 610,
                    y: 660
                }
            },
            plant3: {
                src: '../gameAssets/plant3.png',
                frames: 1,
                scale: 1,
                layer: 11,
                targetPosition: {
                    x: 660,
                    y: 825
                }
            },
            light: {
                src: '../gameAssets/light.png',
                frames: 1,
                scale: 1,
                layer: 12,
                targetPosition: {
                    x: 415,
                    y: 175
                }
            },
            wallShelves: {
                src: '../gameAssets/wallShelves.png',
                frames: 1,
                scale: 1,
                layer: 13,
                targetPosition: {
                    x: 230,
                    y: 225
                }
            },
            window: {
                src: '../gameAssets/window.png',
                frames: 1,
                scale: 1,
                layer: 14,
                targetPosition: {
                    x: 590,
                    y: 220
                }
            }
        };

        const sidebar = document.getElementById('sidebar');
        const gameCanvas = document.getElementById('gameCanvas');
        const activeItems = new Set();

        function snapToGrid(x, y, gridSize = 5) {
            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        function saveItemStates() {
            const itemStates = [];
            const items = gameCanvas.querySelectorAll('.game-item');

            items.forEach((item) => {
                const key = item.dataset.key;
                const position = JSON.parse(item.dataset.position || '{}');
                itemStates.push({
                    key,
                    position
                });
            });

            localStorage.setItem('gameItemStates', JSON.stringify(itemStates));
        }


        function createCanvasItem(key, meta, isClone = false, initialOffset = {
            x: 0,
            y: 0
        }, initialPosition = {
            x: 0,
            y: 0
        }) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            const img = new Image();
            img.src = meta.src;

            let frameWidth, frameHeight;
            let currentFrame = 0;

            canvas.classList.add(isClone ? 'game-item' : 'sidebar-item');

            img.onload = () => {
                frameWidth = img.width / meta.frames;
                frameHeight = img.height;
                canvas.width = frameWidth * meta.scale;
                canvas.height = frameHeight * meta.scale;

                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0, frameWidth, frameHeight, 0, 0, canvas.width, canvas.height);

                if (meta.frames > 1 && isClone) {
                    let lastTime = performance.now();
                    const frameDuration = 200;

                    function animate(time) {
                        const elapsed = time - lastTime;
                        if (elapsed > frameDuration) {
                            currentFrame = (currentFrame + 1) % meta.frames;
                            lastTime = time;
                        }
                        ctx.clearRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(
                            img,
                            currentFrame * frameWidth,
                            0,
                            frameWidth,
                            frameHeight,
                            0,
                            0,
                            canvas.width,
                            canvas.height
                        );
                        requestAnimationFrame(animate);
                    }
                    requestAnimationFrame(animate);
                }
            };

            let offsetX, offsetY;
            let dragging = false;
            let lastTouchX = 0,
                lastTouchY = 0;

            const startDrag = (clientX, clientY) => {
                const rect = canvas.getBoundingClientRect();
                offsetX = clientX - rect.left;
                offsetY = clientY - rect.top;
            };

            const updatePosition = (clientX, clientY) => {
                const gameRect = gameCanvas.getBoundingClientRect();
                let newX = clientX - gameRect.left - offsetX;
                let newY = clientY - gameRect.top - offsetY;
                canvas.style.left = newX + 'px';
                canvas.style.top = newY + 'px';
            };

            const endDrag = (clientX, clientY) => {
                const sidebarRect = sidebar.getBoundingClientRect();
                const gameRect = gameCanvas.getBoundingClientRect();
                const dropX = clientX - gameRect.left - offsetX;
                const dropY = clientY - gameRect.top - offsetY;

                if (clientX >= sidebarRect.left && clientX <= sidebarRect.right &&
                    clientY >= sidebarRect.top && clientY <= sidebarRect.bottom) {
                    if (canvas.parentNode === gameCanvas) gameCanvas.removeChild(canvas);
                    if (!document.getElementById('sidebar-' + key)) {
                        const newItem = createCanvasItem(key, meta);
                        newItem.id = 'sidebar-' + key;
                        sidebar.appendChild(newItem);
                    }
                    activeItems.delete(key);
                } else {
                    let finalX = dropX;
                    let finalY = dropY;

                    if (meta.targetPosition) {
                        const dx = dropX - meta.targetPosition.x;
                        const dy = dropY - meta.targetPosition.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const snapThreshold = 50;
                        if (dist <= snapThreshold) {
                            finalX = meta.targetPosition.x;
                            finalY = meta.targetPosition.y;
                        } else {
                            const snapped = snapToGrid(dropX, dropY);
                            finalX = snapped.x;
                            finalY = snapped.y;
                        }
                    } else {
                        const snapped = snapToGrid(dropX, dropY);
                        finalX = snapped.x;
                        finalY = snapped.y;
                    }

                    canvas.style.left = finalX + 'px';
                    canvas.style.top = finalY + 'px';
                    canvas.style.zIndex = meta.layer || 1;
                    canvas.dataset.position = JSON.stringify({
                        x: finalX,
                        y: finalY
                    });
                    canvas.dataset.key = key;
                    saveItemStates();
                    console.log(`Item "${key}" position: (${finalX}, ${finalY})`);
                }
            };

            const onMouseDown = (e) => {
                dragging = true;
                startDrag(e.clientX, e.clientY);
                document.addEventListener('mousemove', onMouseMove);
                document.addEventListener('mouseup', onMouseUp);
            };
            const onMouseMove = (e) => {
                if (!dragging) return;
                updatePosition(e.clientX, e.clientY);
            };
            const onMouseUp = (e) => {
                if (!dragging) return;
                dragging = false;
                document.removeEventListener('mousemove', onMouseMove);
                document.removeEventListener('mouseup', onMouseUp);
                endDrag(e.clientX, e.clientY);
            };

            const onTouchStart = (e) => {
                if (e.touches.length !== 1) return;
                dragging = true;
                const touch = e.touches[0];
                startDrag(touch.clientX, touch.clientY);
                document.addEventListener('touchmove', onTouchMove, {
                    passive: false
                });
                document.addEventListener('touchend', onTouchEnd);
            };
            const onTouchMove = (e) => {
                if (!dragging || e.touches.length !== 1) return;
                e.preventDefault();
                const touch = e.touches[0];
                lastTouchX = touch.clientX;
                lastTouchY = touch.clientY;
                updatePosition(touch.clientX, touch.clientY);
            };
            const onTouchEnd = () => {
                if (!dragging) return;
                dragging = false;
                document.removeEventListener('touchmove', onTouchMove);
                document.removeEventListener('touchend', onTouchEnd);
                endDrag(lastTouchX, lastTouchY);
            };

            if (isClone) {
                canvas.style.left = initialPosition.x + 'px';
                canvas.style.top = initialPosition.y + 'px';
                canvas.style.zIndex = meta.layer || 1;
                canvas.addEventListener('mousedown', onMouseDown);
                canvas.addEventListener('touchstart', onTouchStart, {
                    passive: false
                });
                canvas.addEventListener('dblclick', () => {
                    if (canvas.parentNode === gameCanvas) gameCanvas.removeChild(canvas);
                    if (!document.getElementById('sidebar-' + key)) {
                        const newItem = createCanvasItem(key, meta);
                        newItem.id = 'sidebar-' + key;
                        sidebar.appendChild(newItem);
                    }
                    activeItems.delete(key);
                });
            } else {
                canvas.id = 'sidebar-' + key;
                canvas.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    if (activeItems.has(key)) return;
                    const sidebarRect = canvas.getBoundingClientRect();
                    const gameRect = gameCanvas.getBoundingClientRect();
                    const offsetX = e.clientX - sidebarRect.left;
                    const offsetY = e.clientY - sidebarRect.top;
                    const posX = e.clientX - gameRect.left - offsetX;
                    const posY = e.clientY - gameRect.top - offsetY;
                    const clone = createCanvasItem(key, meta, true, {
                        x: offsetX,
                        y: offsetY
                    }, {
                        x: posX,
                        y: posY
                    });
                    gameCanvas.appendChild(clone);
                    activeItems.add(key);
                    canvas.remove();
                    const event = new MouseEvent('mousedown', {
                        clientX: e.clientX,
                        clientY: e.clientY
                    });
                    clone.dispatchEvent(event);
                });
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (activeItems.has(key)) return;
                    const touch = e.touches[0];
                    const sidebarRect = canvas.getBoundingClientRect();
                    const gameRect = gameCanvas.getBoundingClientRect();
                    const offsetX = touch.clientX - sidebarRect.left;
                    const offsetY = touch.clientY - sidebarRect.top;
                    const posX = touch.clientX - gameRect.left - offsetX;
                    const posY = touch.clientY - gameRect.top - offsetY;
                    const clone = createCanvasItem(key, meta, true, {
                        x: offsetX,
                        y: offsetY
                    }, {
                        x: posX,
                        y: posY
                    });
                    gameCanvas.appendChild(clone);
                    activeItems.add(key);
                    canvas.remove();
                    clone.dispatchEvent(new TouchEvent('touchstart', {
                        touches: [touch],
                        cancelable: true,
                        bubbles: true
                    }));
                }, {
                    passive: false
                });
            }

            return canvas;
        }

        function logAllItemPositions() {
            const items = gameCanvas.querySelectorAll('.game-item');
            items.forEach((item, i) => {
                const key = item.dataset.key || `item-${i}`;
                const pos = JSON.parse(item.dataset.position || '{}');
                console.log(`${key}:`, pos);
            });
        }
        // Khôi phục trạng thái nếu có
        const savedStates = JSON.parse(localStorage.getItem('gameItemStates') || '[]');
        const keysPlaced = new Set();

        savedStates.forEach(({
            key,
            position
        }) => {
            if (items[key]) {
                const meta = items[key];
                const clone = createCanvasItem(key, meta, true, {}, position);
                clone.dataset.position = JSON.stringify(position);
                clone.dataset.key = key;
                gameCanvas.appendChild(clone);
                activeItems.add(key);
                keysPlaced.add(key);
            }
        });

        for (const key in items) {
            if (!keysPlaced.has(key)) {
                const canvas = createCanvasItem(key, items[key]);
                canvas.id = 'sidebar-' + key;
                sidebar.appendChild(canvas);
            }
        }
    </script>
</body>

</html>